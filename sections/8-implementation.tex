\chapter{Implementation}\label{ch:implementation}

% Mention that its the alperin-sheriff peikert implementation of GSW
% The goal is to bootstrap by evaluating the decfryption algorithm. We need the the homomorphic version of inner product of two ciphertexts (s' and c) and we need the rounding function f:Z_q -> {0,1}
% To do the inner product

% Alperin-Sheriff-Peikert system implies hardness of LWE within O(n^2,5) approximation factor whereas Brakerski and Vaikuntanathan system implies hardness of LWE within O(n^1,5) which is optimal since this is the best (smallest) approximation factor for non homomorphic public key encryption schemes.

%Intro:
In this chapter we will present a fully homomorphic encryption scheme, called GSW, developed by Gentry, Sahai and Waters \cite{GSW13}. The GSW scheme is based on matrices and approximate eigenvectors. The appeal of the scheme is its relative conceptual simplicity due to natural matrix addition and matrix multiplication operations. This chapter is based on the implementation in the follow up work of Alperin-Sheriff and Peikert \cite{A-S-P-boot}. Alperin-Sheriff and Peikert introduced a syntactically simpler implementation of the GSW together with a new bootstrapping algorithm. Their bootstrapping algorithm relies on representing integers as tuples of cyclic shifts, as discussed in Section \ref{sec:embedding}, and decrypting a ciphertext homomorphically using the inner product and an appropriate rounding function. To minimize confusion, we generally use similar notation to \cite{A-S-P-boot}.

This chapter is structured by presenting concepts as follows: We present the GSW scheme, which is used to encrypt bits. We show the scheme's correctness, security guarantees, homomorphic operations and bounds on error growth. Then, we introduce the slightly more general HEPerm scheme, which is used to encrypt integers encoded as cyclic shift permutations by using the GSW scheme to encrypt each bit. We introduce two operations to HEPerm, called homomorphic composition and homomorphic equality test and then prove results on error growth similar to those in GSW. Finally, we present the bootstrapping algorithm and show how to decrypt a ciphertext homomorphically using the inner product and an appropriate rounding function. We then prove results for the bound of the error associated to the refreshed ciphertext. Specifically we show that the refreshed ciphertext has an associated subgaussian error vector with parameter small enough to decrypt correctly except for negligible probability.

At a high level, the idea behind this chapter is to concretely demonstrate a protocol for which a server can compute the data of a client, homomorphically. More specifically, for any program with arbitrary complexity, we show how a server can execute the program using only encryptions of the input bits, encryption of the secret key and the program's Boolean circuit representation of XOR and AND gates. The protocol has the client encrypting their input bits using the GSW scheme and their secret key using the HEPerm scheme. The client sends encrypted data to the server which runs the matrices through the homomorphic version of the circuit, where each XOR and AND gate is swapped for the corresponding addition and multiplication operation of the GSW scheme. If the depth of the circuit is known to be small a priori, then there is an efficient GSW initialization such that the error growth associated with the ciphertext matrices in the homomorphic version of the program does not cause decryption to fail. In this case, the server simply runs the homomorphic version of the circuit and sends back the GSW ciphertexts to the client who decrypts them for the final result. On the other hand, if the depth of the circuit is unspecified, the server may need to refresh the ciphertext matrices using the bootstrapping algorithm. For the bootstrapping algorithm, the client sends the server their encrypted secret key using the HEPerm scheme. The server then runs the decryption function homomorphically (i.e., by using the encrypted secret key) to reduce the noise and continues to run the homomorphic version of the circuit on the refreshed ciphertext.

\section{Flattening gadget}

In the implementation of the GSW scheme, the ciphertexts are matrices defined over $\mathbb{Z}_q^{n \times nl}$ where $l = \lceil \log q \rceil$. To avoid rapid error growth under homomorphic multiplication, we want to represent integers mod q as a corresponding low norm vector through the decomposition function (also called flattening gadget) $G^{-1}$. To get back the original integer $x$ we require $\left \langle \mathbf{g}, G^{-1}(x) \right \rangle = x$ where $\mathbf{g} \stackrel{\mathrm{def}}{=} (1, 2, \dots, 2^{l-1}) \in \mathbb{Z}_q^l$. A particular number of interest later is the penultimate entry $2^{l-2}$. Since $2^l \in [q, 2q)$ we have $2^{l-2} \in [q/4, q/2)$. 

We can easily extend the decomposition function to work on vectors and matrices by applying the function to each element in the vector or matrix. For a column vector $\mathbf{v} \in \mathbb{Z}_q^n$, we define the column vector $G^{-1}(\mathbf{v}) \stackrel{\mathrm{def}}{=} [G^{-1}(v_1)|G^{-1}(v_2)| \dots |G^{-1}(v_n)] \in \mathbb{Z}^{nl}$ and for a matrix $\mathbf{A} \in \mathbb{Z}_q^{n \times m}$, define $G^{-1}(\mathbf{A}) \stackrel{\mathrm{def}}{=} [G^{-1}(a_1)|G^{-1}(a_2)| \dots |G^{-1}(a_m)] \in \mathbb{Z}^{nl \times m}$ where $a_i$ is the $i$:th column of $\mathbf{A}$. Then, for any integer ($n = m = 1$), vector ($n$ or $m$ is 1) or matrix $x \in \mathbb{Z}_q^{n \times m}$ we have $\mathbf{G}G^{-1}(x) = x$ where 
\begin{equation*}
    \mathbf{G} \stackrel{\mathrm{def}}{=}
    \left[
        \begin{array}{ccccccccccccc}
        1 & 2 & \cdots & 2^{l-1} \\
         & & & & 1 & 2 & \cdots  & 2^{l-1} \\
         & & & & & & & & \ddots \\
         & & & & & & & & & 1 & 2 & \cdots & 2^{l-1}
        \end{array}
    \right] \in \mathbb{Z}_q^{n \times nl}
\end{equation*}
A simple way to implement the $G^{-1}$ mapping is to map an integer $x \in \mathbb{Z}_q$ to its bit decomposition vector $\{0,1\}^{l}$. In the original implementation of the GSW scheme \cite{GSW13}, the decomposition function was precisely the bit decomposition function. However, in the implementation of Alperin-Sheriff and Peikert \cite{A-S-P-boot}, the decomposition function is a randomized algorithm $G^{-1} \colon \mathbb{Z}_q \to \mathbb{Z}^{l}$ where every coordinate of $G^{-1}(x)$ is a subgaussian distribution over the integers with constant parameter. The reason for a randomized decomposition function is twofold: First, we can use subgaussian random variables for a tight error analysis when multiplying ciphertexts. Second, in the ofchance that a subgaussian error has large norm, it can easily be resampled.

\begin{theorem}[Claim 3.1 \cite{A-S-P-boot}]\label{thm:decomposition}
    There is a randomized, efficiently computable function $G^{-1}: \mathbb{Z}_q \rightarrow \mathbb{Z}^{\ell}$ such that $G^{-1}(a)$ is a subgaussian random variable with parameter $O(1)$, and always satisfies $\left \langle \mathbf{g}, G^{-1}(a) \right \rangle=a$. 
\end{theorem}

Remark that, more generally, by applying $G^{-1}$ on every element of a vector or matrix $x$, $\mathbf{G}G^{-1}(x) = x$. Notice that $\mathbf{G}G^{-1}$ acts as an identity mapping, unlike the randomized matrix $G^{-1}(\mathbf{G})$. We will use the above theorem and its implementation as a black box but the following example provides some intuition.  

As an example, consider $q = 8$ and say we want to decompose the integer $5$. Then $(1,0,1)$ and $(-1,3,0)$ are both valid samples of $G^{-1}(5)$ since $1 \cdot 1 + 0\cdot 2 + 1\cdot 2^2 = 5$ and $-1 \cdot 1 + 3 \cdot 2 + 0\cdot 2^2 = 5$. Remember that the samples have "small" entries as they are subgaussian with constant parameters (more specifically, the magnitude of the entries do not grow with $q$).

\section{GSW scheme}
Here we give a high level description of the GSW scheme. In the GSW scheme, the message is a bit $\mu$ and the ciphertext is a matrix $c \in \mathbb{Z}_q^{n \times nl}$. The GSW ciphertext matrix is, in some sense, a linear map where the secret key is an approximate eigenvector with a message bit as eigenvalue. In more detail, the secret vector $s \in \mathbb{Z}_q^n$ should satisfy $s^T c = \mu s^T\mathbf{G} + e^T$ for some message bit $\mu$ and some small error vector $e \in \mathbb{Z}_q^{nl}$ associated with ciphertext $c$. This equation is ubiquitous in the GSW scheme and is denoted the \textit{invariant equation}. The intuition is to hide the bit in a LWE sample by adding $\mu \mathbf{G}$ to the sample. The security of the scheme is based on the LWE hardness assumption. The error distribution is the discrete Gaussian $\chi = \textrm{D}_{\mathbb{Z}, s, \vec{0}}$ with the error bound $\beta$. The scheme is thus parameterized by the tuple $(n, q, \chi, m)$ where $n(\lambda), q(\lambda), m(\lambda)$ are integers and $\chi$ is a distribution. 
For ciphertexts $c_1, c_2 \in \mathbb{Z}_q^{n \times nl}$, the homomorphic addition is defined as normal matrix addition whereas homomorphic multiplication is defined as the following right associative operation: $c_1 \times G^{-1}(c_2)$.

\begin{enumerate}
    \item \textbf{Key generation}: Generate a uniformly random $\operatorname{LWE}$ secret $s' = (s_1, \dots, s_{n-1}) \leftarrow \mathbb{Z}_q^{n-1}$ and let $s = (s_1, \dots, s_{n-1}, s_n \stackrel{\mathrm{def}}{=} -1) \in \mathbb{Z}_q^{n}$. Using $s'$, generate the $n \times m$ matrix $\mathbf{A}' \stackrel{\mathrm{def}}{=} (\mathbf{A}, b^T) \leftarrow \operatorname{LWE}_{n-1,q,\chi,m}$. Let $\text{KeyGen}(1^\lambda, 1^L)$ return $\mathbf{A}' \in \mathbb{Z}_q^{n \times m}$ as the public key and $s \in \mathbb{Z}_q^n$ as the secret key. 
    \item \textbf{Encryption}: Generate a random 'subset' matrix $\mathbf{R} \leftarrow \{0,1\}^{m \times nl}$. To encrypt a bit $\mu$, compute $c \leftarrow \text{Enc}(\mathbf{A}',\mu) \stackrel{\mathrm{def}}{=} \mu \mathbf{G} + \mathbf{A}'\mathbf{R} \pmod q \in \mathbb{Z}_q^{n\times nl}$.
    \item \textbf{Evaluation}: For a given Boolean circuit, swap each addition gate to the standard matrix addition function $\boxplus \colon (c_1,c_2) \mapsto c_1 + c_2$ and swap each multiplication gate to $\boxdot \colon (c_1, c_2) \mapsto c_1 \times G^{-1}(c_2)$. Remark that multiplication is right associative.
    \item \textbf{Decryption}: Define the rounding function $[\cdot]_2 \colon \mathbb{Z}_q \to \{0,1\}$ where $[x]_2 = 0$ if $x \pmod q$ is closer to $0$ than $2^{l-2}$ and $[x]_2 = 1$ otherwise. Decryption is defined as $[\left \langle s,c_{pen} \right \rangle \pmod q]_2$ where $c_{pen}$ is the penultimate column of ciphertext $c$ and $s$ is the secret key. 
\end{enumerate}

Before analyzing the scheme, we define some basic concepts and briefly discuss the scheme
\begin{definition}
    A fresh ciphertext $c \in \mathbb{Z}_q^{n \times nl}$ is \textit{designed to encrypt} bit $\mu$ if $c \leftarrow \text{Enc}(\mathbf{A}',\mu)$. A ciphertext sum $c_1 \boxplus c_2$ is \textit{designed to encrypt} bit $\mu_1 + \mu_2 \in \mathbb{Z}_2$ if $c_1$ and $c_2$ are designed to encrypt $\mu_1, \mu_2$ respectively. A ciphertext product $c_1 \boxdot c_2$ is \textit{designed to encrypt} bit $\mu_1 \cdot \mu_2 \in \mathbb{Z}_2$ if $c_1$ and $c_2$ are designed to encrypt $\mu_1, \mu_2$ respectively.
\end{definition}
Remark that the matrix $\mathbf{G}$ is a valid fresh encryption of the bit $1$ where the random matrix is all zeros. $\mathbf{G}$ is therefore designed to encrypt $1$. We will use $\mathbf{G}$ as an encryption of $1$ to simplify the error analysis of homomorphic multiplication later. 

Denote the error from the LWE samples by $e_{LWE} \in \mathbb{Z}_q^m$. Then, we know that $s^T\mathbf{A}' = e_{LWE}$. This error is associated with the LWE samples $\mathbf{A}'$ used to generate the ciphertext $c$. We are interested in a related but different error directly associated with $c$ through the expression $s^Tc$.
For a fresh ciphertext $c$ with corresponding secret key $s$, notice that $s^Tc = \mu s^T\mathbf{G} + s^T\mathbf{A}'\mathbf{R} = \mu s^T\mathbf{G} + e_{LWE}^T\mathbf{R} \in \mathbb{Z}_q^{nl}$. Since $e_{LWE}$ is sampled from the subgaussian distribution $\chi^m$, each element $e_1, \dots, e_m$ is subgaussian with parameter $s$. Therefore, $e_{LWE}^T\mathbf{R}$ is a row vector where each element is an inner product of at most $m$ subgaussian random variables. By additivity of subgaussian random variables, Lemma \ref{lemma:add-subgaussian} gives that each element in the row vector is subgaussian with parameter $\sqrt{ms^2} = s\sqrt{m}$. Consequently, $e_{LWE}^T\mathbf{R}$ is a subgaussian row vector in $\mathbb{Z}_q^{nl}$ with parameter $s\sqrt{m}$. Remark that $e_{LWE}^T\mathbf{R}$ is directly associated with $c$. We simply denote its transpose (i.e., the column vector) $e$ and call it the \textit{ciphertext error} or the error associated with the ciphertext $c$. Each ciphertext matrix has its own associated error vector in $\mathbb{Z}_q^{nl}$ and each fresh ciphertext has an associated LWE error vector $e_{LWE} \in \mathbb{Z}_q^{m}$ sampled from $\chi^m$. 

The rounding function in the decryption function outputs $0$ if and only if $|x - 0 \pmod q| < |x - 2^{l-2} \pmod q|$ and 1 otherwise. The idea of the rounding function is to remove all ciphertext noise embedded in $\left \langle s,c_{pen} \right \rangle \pmod q$. To do so, we require that the noise is small enough so that the message is not mistaken as the other bit. Specifically, the bit $0$ is associated with inner product being close to $0$ and the bit $1$ is associated with inner product being close to $2^{l-2}$. To implement the bootstrapping algorithm we need to decrypt, and in particular calculate the rounding function, homomorphically. The server can do this by comparing the inner product to all good values in the domain of the rounding function using the homomorphic equality test, as we will se later.

\subsection*{Correctness}
Consider a ciphertext $c = \mu \cdot \mathbf{G} + \mathbf{A}'\mathbf{R} \pmod q$ for some random binary matrix $\mathbf{R}$. Then, the penultimate column is $c_{pen} = \mu (0, \dots, 0, 2^{l-2}) + \mathbf{A}' \mathbf{R}_{pen}$ where $\mathbf{R}_{pen} \in \{0,1\}^{m}$ is the penultimate column of $\mathbf{R}$. Remember that $2^{l-2} \in [q/4, q/2)$. Therefore, $\left \langle s, c_{pen} \right \rangle = s^Tc_{pen} = - \mu 2^{l-2} + (s^T \mathbf{A}') \mathbf{R}_{pen} = - \mu 2^{l-2} + e_{pen}$ where $e_{pen}$ is the penultimate element of the error vector $e$ associated with $c$. Notice that for small error (i.e., zero error) $e_{pen}$, the bit $\mu = 0$ is clearly rounded to 0. For the bit $\mu = 1$, since $-2^{l-2} \in (-q/2, -q/4]$ we have $-2^{l-2} \pmod q \in (q/2, 3q/4]$. Therefore, any $-2^{l-2} \pmod q$ is closer to $2^{l-2}$ than $0$ and the bit $\mu = 1$ is rounded to 1 \mrnote{MAKE MORE CLEAN ARGUMENT?}. What remains is to analyze the effect of the error. By above argument, $e_{pen}$ is subgaussian with parameter at most $\|e\|$. From an error standpoint, in the worst case $l$ is equal to $q/4$ since this is when $0$ and $2^{l-2}$ are the closest, leaving less room for the magnitude of the error before the rounding function is mapped incorrectly. Therefore, for correct rounding and thus ultimately correct decryption, it is necessary that $|e_{pen}| < q/8$ because this implies that the error is too small to cause the rounding function to output the wrong bit. By definition of subgaussian random variables, $\operatorname{Pr}[|e_{pen}| > q/8] \leq 2\exp \left(- \pi \frac{q^2}{64\|e\|^2} \right) = negl(q)$ for $\beta$-bounded error $e$. \mrnote{CHECK LAST PART AGAIN}

\subsection*{Security}
The intuition behind the scheme is to hide the plaintext bit in a LWE sample. Semantic security follows from the LWE hardness assumption. Since, by assumption, $\mathbf{A}'$ is pseudorandom and $/textbf{R}$ is uniformly random, $\mathbf{A}'\mathbf{R}$ is also pseudorandom. Furthermore, adding $\mathbf{G}$ only translates the distributions, and thus maintains pseudorandomness. In other words, if there is an adversary that can distinguish encryptions of $0$ and encryptions of $1$, then it can distinguish between $\mathbf{A}'\mathbf{R}$ and $\mathbf{A}'\mathbf{R} + \mathbf{G}$ which is a contradiction to the LWE hardness assumption. 

\subsection*{Preserving design under homomorphic operations}
Stating that a ciphertext is designed to encrypt a bit is intended as a more relaxed concept of correctness in the sense that if $c$ is designed to encrypt $\mu$, then $c$ decrypts to $\mu$ assuming the associated error vector is zero. For this definition of design to make sense, we need to show that the homomorphic operations indeed does decrypt correctly, given sufficiently small error. We say that the homomorphic operation \textit{preserve design}.
Let $c_1, c_2 \in \mathbb{Z}_q^{n \times nl}$ be two ciphertexts designed to encrypt the bits $\mu_1, \mu_2$ with associated errors $e_1, e_2$ respectively. In this paragraph, we show that the homomorphic operations decrypts correctly for small errors and we later analyze the error growth. We then In other words, we show that $c_1 \boxplus c_2$ decrypts to $\mu_1 + \mu_2 \pmod 2$ and $c_1 \boxdot c_2$ decrypts to $\mu_1 \mu_2$. Remember, homomorphic addition $c = c_1 \boxplus c_2$ is defined as standard matrix addition and homomorphic multiplication is right associative and defined as $c_1 G^{-1}(c_2)$. The invariant equation for the sum is
\begin{equation}\label{eq:invariant_sum}
    \begin{aligned}
    s^Tc &= s^T(c_1 + c_2) = s^Tc_1 + s^Tc_2 = s^T \mathbf{G}\mu_1 + e_1^T + s^T \mathbf{G} \mu_2 + e_2^T \\
    &= s^T\mathbf{G}(\mu_1 + \mu_2) + [e_1^T + e_2^T] \in \mathbb{Z}_q^{nl}    
    \end{aligned}
\end{equation}
where the square brackets denote the error associated with the homomorphic sum. Briefly assume the errors are small (say zero). Since the penultimate element of $s^T\mathbf{G}$ is $\left \langle (s_1, \dots, s_{n-1}, -1),(0, \dots, 0, 2^{l-2} \right \rangle = -2^{l-2}$, decryption for small errors yields $[-2^{l-2}(\mu_1 + \mu_2)]_2$. To argue correctness of decryption, by using the same argument as before, we see that the only relevant case is when $\mu_1 = \mu_2 = 1$. Then, $-2^{l-2}(1 + 1) = - 2^{l-1} \in (-q,-q/2]$ and thus $- 2^{l-1} \pmod q \in (0,q/2]$ and indeed the homomorphic addition of ciphertexts both designed to encrypt $1$ yields a ciphertext designed to encrypt $0$.
The invariant equation for the product is
\begin{equation}\label{eq:invariant_product}
    \begin{aligned}
    s^T(c_1 \boxdot c_2) &= s^T(c_1 G^{-1}(c_2)) = s^T(c_1)G^{-1}(c_2) = (s^T\mathbf{G}\mu_1 + e_1^T)G^{-1}(c_2) \\
    &= \mu_1 s^T \mathbf{G}G^{-1}(c_2) + e_1^TG^{-1}(c_2) = \mu_1 s^T(c_2) + e_1^TG^{-1}(c_2) \\
    &= \mu_1(s^T\mathbf{G}\mu_2 + e_2^T) + e_1^TG^{-1}(c_2)\\
    &= \mu_1\mu_2 s^T\mathbf{G} + [e_1^TG^{-1}(c_2) + \mu_1 e_2^T] \in \mathbb{Z}_q^{nl}
    \end{aligned}
\end{equation}
where, again, the square brackets denote the error associated with the homomorphic multiplication. Assuming small errors again and the decryption function becomes $[-2^{l-2}\mu_1 \mu_2]_2$. It is clear by the same argument as before that this decrypts to $1$ if and only if $\mu_1 \mu_2 = 1$, meaning $\mu_1 = \mu_2 = 1$ and correctness holds.

\subsection*{Error growth of homomorphic operations}
The square brackets in Equation $\ref{eq:invariant_sum}$ and $\ref{eq:invariant_product}$ show how the associated error grows under homomorphic addition and multiplication. For addition, we observe that the error is merely added together and thus subgaussian by \ref{lemma:add-subgaussian}. For multiplication however, we use the fact that $\mathbf{G}$ is designed to encrypt $1$ and has zero error associated with it. Then, $c_2 \boxdot \mathbf{G}$ is designed to encrypt $\mu_2$ and $c_1 \boxdot (c_2 \boxdot \mathbf{G})$ is designed to encrypt $\mu_1 \mu_2$. The reason for expressing the product ciphertext of $\mu_1 \mu_2$ as $c_1 \boxdot (c_2 \boxdot \mathbf{G})$ instead of as $c_1 \boxdot c_2$ is to simplify the error analysis. More specifically, by performing the multiplication $c_2 \boxdot \mathbf{G}$ first, we ensure that $G^{-1}$ is applied to $c_2$ as well, which gives us the following clean error analysis
\begin{theorem}\label{thm:hom_product}
    Let $c_1, c_2 \in \mathbb{Z}_q^{n \times nl}$ be two ciphertexts designed to encrypt the bits $\mu_1, \mu_2$ with associated errors $e_1, e_2$ respectively. Then, $c_1 \boxdot c_2 \boxdot \mathbf{G}$ is designed to encrypt $\mu_1 \mu_2$ and its associated error is subgaussian with parameter $O(\|e\|)$ where $e = (e_1, e_2) \in \mathbb{Z}^{2nl}$ is the concatenation of the two errors. 
\end{theorem}
\begin{proof}
    Remember that $\boxdot$ is right associative, meaning we first compute $c_2 \boxdot \mathbf{G}$ and then $c_1 \boxdot (c_2 \boxdot \mathbf{G})$. The invariant equation, Equation $\ref{eq:invariant_product}$, gives that the error associated with $c_2 \boxdot \mathbf{G}$ is $e_2^TG^{-1}(\mathbf{G})$ since $\mathbf{G}$ has zero error. Remember that $G^{-1}$ applied on a matrix is defined by applying the decomposition function $G^{-1}$ on every element of the matrix. Therefore, $G^{-1}(G)$ is a $nl \times nl$ matrix where column $j$ contains $n$ decompositions, each containing $l$ integers. By Theorem $\ref{thm:decomposition}$, each of the $n$ decomposition vectors in column $j$ is subgaussian with parameter $O(1)$, and therefore the concatenation, meaning the entire column $j$, is also subgaussian with parameter $O(1)$. To analyze the error vector $e_2^TG^{-1}(\mathbf{G}) \in \mathbb{Z}_q^{nl}$ associated with $c_2 \boxdot \mathbf{G}$, consider element $j \in [nl]$. Element $j$ is simply an inner product of $e_2$ and column $j$ of $G^{-1}(\mathbf{G})$. By Lemma \ref{lemma:Ver12}, element $j$ is therefore subgaussian with parameter $O(\|e_2\|)$. The same analysis holds for every element in $e_2^TG^{-1}(\mathbf{G})$ and thus, the error associated with $c_2 \boxdot \mathbf{G}$ is subgaussian with parameter $O(\| e_2 \|)$.
    Consider now $c_1 \boxdot (c_2 \boxdot \mathbf{G})$. The invariant equation, Equation $\ref{eq:invariant_product}$, gives that the error associated with $c_1 \boxdot (c_2 \boxdot \mathbf{G})$ is $e_1^TG^{-1}(c_2 \boxdot \mathbf{G}) + \mu_1 e_2^TG^{-1}(\mathbf{G})$. Notice that the second term is, by above argument, subgaussian with parameter $O(\|e_2\|)$. Consider the first term, $e_1^TG^{-1}(c_2 \boxdot \mathbf{G})$. Remember that $c_2 \boxdot \mathbf{G}$ is a valid ciphertext designed to encrypt $\mu_2$ similar to how $\mathbf{G}$ is designed to encrypt the bit $1$. By the same argument as before, $e_1^TG^{-1}(c_2 \boxdot G)$ is subgaussian with parameter $O(\|e_1\|)$. By Lemma \ref{lemma:add-subgaussian}, the sum of subgaussian vector with parameters $\|e_1\|$ and $\|e_2\|$ is subgaussian with parameter $\sqrt{\|e_1\|^2 + \|e_2\|^2} = \|e\|$ where $e = (e_1, e_2) \in \mathbb{Z}^{2nl}$ is the concatenation of the two errors. Homogenity of vectors from Lemma \ref{lemma:add-subgaussian} concludes the proof.
\end{proof}
The above theorem can, by induction, be extended to a homomorphic product of $D$ ciphertexts. 
\begin{corollary}\label{cor:hom_product}
    Let $c_1, \dots, c_k$ be GSW ciphertext designed to encrypt $\mu_1, \dots, \mu_k$ with associated errors $e_1, \dots, e_k \in \mathbb{Z}_q^{nl}$, respectively. Then,
    \begin{equation}
        c_1 \boxdot \dots \boxdot c_k \boxdot \mathbf{G} 
    \end{equation}
    is designed to encrypt $\mu_1 \times \dots \times \mu_k$ and its associated error is subgaussian with parameter $O(\|e\|)$ where $e = (e_1, \dots, e_k) \in \mathbb{Z}^{knl}$ is the concatenation of the $k$ errors.
\end{corollary}
\begin{proof}
    The base case follows from Theorem \ref{thm:hom_product}.
    Notice that the invariant equation states that every new ciphertext we multiply into the existing chain of ciphertexts, the error vector grows by an extra error term. More specifically, multiplying $c_i$ to the existing chain $c_{i+1} \boxdot \dots \boxdot c_k \boxdot \mathbf{G}$ adds the error vector term $e_i^TG^{-1}(c_{i+1} \boxdot \dots \boxdot c_k \boxdot \mathbf{G})$ to the error of the product ciphertext. Thus, the error associated with $c_1 \boxdot \dots \boxdot c_k \boxdot \mathbf{G}$ is $\sum_{i = 1}^k e_i^TG^{-1}(c_{i+1} \boxdot  \dots \boxdot c_k \boxdot \mathbf{G})$. Each term is subgaussian with parameter $O(\|e_i\|)$ by same argument as above and the result follows by addition of subgaussian vectors and homogenity, by Lemma \ref{lemma:add-subgaussian}.
\end{proof}

\section{HEPerm scheme}
Remember that integers can be represented as tuples of cyclic shifts through the canonical homomorphism, see Definition \ref{def:canonical-homomorphism}. Since cyclic shifts are represented as indicator vectors, encrypting the tuples of cyclic shifts corresponds to encrypting integers. The reason for using cyclic shifts is that composition makes computing homomorphic addition easy. The GSW scheme is used to encrypt bits and the HEPerm scheme is used to encrypt integers by encrypting the cyclic shift corresponding to the integer, using the GSW scheme as a subroutine. To simplify notation, we denote the space of GSW ciphertexts as $\mathcal{Y} = \mathbb{Z}_q^{n \times nl}$ and we denote the space of associated errors as $\mathcal{E} = \mathbb{Z}_q^{nl}$.

\begin{enumerate}
    \item \textbf{Key generation}: Same as GSW scheme.
    \item \textbf{Encryption}: For a given cyclic shift $\pi \in \{0,1\}^r$, expand $\pi$ to its permutation matrix $\mathbf{P}^{\pi} \in \{0,1\}^{r \times r}$ and encrypt each bit in $\mathbf{P}^\pi$ by using the GSW scheme. Output the encrypted matrix $\mathbf{C}^{\pi} \in \mathcal{Y}^{r \times r}$. 
    \item \textbf{Decryption}: For a given HEPerm ciphertext in $\mathcal{Y}^{r \times r}$, apply the GSW decryption function on each GSW ciphertext in the first column. Return the unencrypted first column in $\{0,1\}^r$.
\end{enumerate}
Similarly to the GSW scheme, every HEPerm ciphertext $\mathbf{C}^{\pi} = (c_{i,j})_{i,j \in [r]} \in \mathcal{Y}^{r \times r}$ has an error associated with it. $\mathbf{E}^{\pi} = (e_{i,j})_{i,j \in [r]} \in \mathcal{E}^{r \times r}$ is the error associated with $\mathbf{C}^{\pi}$ if every $e_{i,j}$ is the error associated with GSW ciphertext $c_{i,j} \in \mathcal{Y}$. Similarly to how $\mathbf{G}$ encrypts the multiplicative identity (i.e., the bit $\mu = 1$) with zero error, we define the HEPerm ciphertext $\mathbf{J} \in \mathcal{Y}^{r \times r}$ as an encryption of the identity cyclic shift $(1, 0, 0, \dots, 0) \in \{0,1\}^{r}$. In other words, $\mathbf{J}$ is an encryption of the identity matrix, containing GSW ciphertexts with zero errors.

Notice that HEPerm is a slight generalization of GSW scheme. Correctness and security follows immediately from the GSW scheme. We will use the HEPerm scheme to implement the bootstrapping algorithm, allowing homomorphic decryption. To do so, we need to compute the inner product $\left \langle s,c \right \rangle$ and the rounding function homomorphically. This requires two operations on HEPerm ciphertexts: composition and equality test. Remember that normal matrix multiplication of permutation matrices corresponds to addition of the underlying integers, mod $r$ (see Section \ref{sec:composition_addition}). The composition operation of the HEPerm scheme is a matrix multiplication of the HEPerm ciphertexts, using $\boxplus$ and $\boxdot$ for addition and multiplication of GSW ciphertexts. The composition of two HEPerm ciphertexts corresponds to modular addition of the unencrypted integers. Equality test is an operation used to implement the rounding function. It pick out one of the GSW ciphertexts in the HEPerm ciphertext, returning a GSW ciphertext designed to encrypt 1 if and only if the encrypted integer is equal to the integer we are testing for. More formally, the operations are defined as follows:
\begin{definition}[HEPerm composition]
    Define the map $\boxring \colon \mathcal{Y}^{r \times r} \times \mathcal{Y}^{r \times r} \to \mathcal{Y}^{r \times r}$ as a right associative matrix multiplication where the addition operation is replaced by $\boxplus$ and the multiplication operation is replaced by $\boxdot$. More precisely, given the two HEPerm ciphertexts $\mathbf{C}^{\pi} = (c_{i,j}^{\pi} \in \mathcal{Y}), \mathbf{C}^{\sigma} = (c_{i,j}^{\sigma} \in \mathcal{Y}) \in \mathcal{Y}^{r \times r}$ element $c_{i,j}$ of $\mathbf{C}^{\pi} \boxring \mathbf{C}^{\sigma}$ is defined as
    \begin{equation}\label{HEPerm_composition}
        c_{i,j} = \bigboxplus\limits_{l \in [r]} c_{i,l}^{\pi} \boxdot c_{l,j}^{\sigma}
    \end{equation}
\end{definition}
\begin{remark}
    Note that homomorphic addition of integers is denoted by a square with a ring inside using HEPerm ciphertexts whereas homomorphic multiplication of bits is denoted by a square with a dot inside using GSW ciphertexts.
\end{remark}
We now argue that $\mathbf{C}^{\pi} \boxring \mathbf{C}^{\sigma}$ preserves the design, meaning that we argue that the first column $(c_{i,1})_{i \in [r]} \in \mathcal{Y}^r$ of $\mathbf{C}^{\pi} \boxring \mathbf{C}^{\sigma}$ is designed to encrypt $\pi \circ \sigma$. Note that every GSW ciphertext element in $(c_{i,1})_{i \in [r]}$ is an inner product of two $r$ dimensional vectors (row $i$ of $\mathbf{C}^{\pi}$ and column $1$ of $\mathbf{C}^{\sigma}$) of GSW ciphertexts. Since $\boxdot$ and $\boxplus$ preserves design, every element preserves design and therefore $\boxring$ preserves design too. 

Notice that the first column of $\mathbf{C}^\pi$ contains the encryption of $\pi$. This suggests that it is unnecessary to expand $\pi$ into its permutation matrix, saving us $r^2 - r$ GSW encryptions and $(r-1)rn^2l \log q$ bits of space per HEPerm ciphertext. However, the composition operation requires the left HEPerm ciphertext to be square: it is impossible to expand a column ciphertext designed to encrypt an integer correctly as there is no way to know what the integer is. On the other hand, if we are told what integer the ciphertext encrypts, then the first column of the HEPerm ciphertext is sufficient. We can use this fact to implement the equality test operation by choosing exactly one GSW ciphertext in the first column of the HEPerm ciphertext, as seen below. 

\begin{definition}[Equality test]
    Define the map $\text{Eq?} \colon \mathcal{Y}^{r} \times C_r \to \mathcal{Y}$ as follows. Given an HEPerm column ciphertext $\mathbf{C} = (c_1, \dots, c_r) \in \mathcal{Y}^r$ designed to encrypt a cyclic shift and an unencrypted cyclic shift $\pi = (b_1, \dots, b_r) \in \{0,1\}^r$ where $b_i = 1$ for exactly one $i \in [r]$, return $c_i$. In other words
    \begin{equation}
        \text{Eq?}(\mathbf{C}, \pi) = c_i \in \mathcal{Y}
    \end{equation}
\end{definition}
Notice that the equality test function $\text{Eq?}$ returns a GSW ciphertext designed to encrypt $1$ if and only if $\mathbf{C}$ is designed to encrypt $\pi$. In other words, the equality test function takes a HEPerm ciphertext encrypting some cyclic shift and returns a GSW ciphertext designed to encrypt $1$ if and only if it also receives the correct cyclic shift. We use the equality test function to implement the rounding function homomorphically by testing if the encrypted rounding function input (represented by $\mathbf{G}$) is designed to encrypt an integer that is supposed to be rounded to $1$. If and only if that is the case does the equality test function output a GSW ciphertext designed to encrypt 1.

We now show that the HEPerm composition operation $\boxring$ exhibits very similar error growth to the GSW composition operation $\boxdot$. In the following proof, denote $\mathbf{J}$ as $(J_{i,j}) \in \mathcal{Y}^{r \times r}$. 
\begin{lemma}\label{lemma:HEperm_error}
    Let $\mathbf{C}^{\sigma} = (c^{\sigma}_{i,j}) \in \mathcal{Y}^{r \times r}$ be a HEperm ciphertext designed to encrypt the cyclic shift $\sigma \in C_r$ with associated error $\mathbf{E}^{\sigma} = (e^{\sigma}_{i,j}) \in \mathcal{E}^{r \times r}$. Then, $\mathbf{C}^{\sigma} \boxring \mathbf{J}$ is designed to encrypt $\sigma$ and its associated error is $\mathbf{E}^{\sigma} G^{-1}(\mathbf{J}) \in \mathcal{E}^{r \times r}$. Furthermore, row $i$ is subgaussian vector over $\mathcal{E}^r$ with parameter $O(\|e^{\sigma}_i\|)$ where $e^{\sigma}_i$ is the $i$:th row of $\mathbf{E}^{\sigma}$. 
\end{lemma}
\begin{proof}
    The fact that $\mathbf{C}^{\sigma} \boxring \mathbf{J}$ preserves design follows immediately from the fact that $\boxdot$ and $\boxplus$ preserves design, the definition of $\boxring$ and the fact that $\mathbf{J}$ is designed to encrypt the identity cyclic shift.
    By Equation \ref{HEPerm_composition}, the GSW ciphertext on row $i$ and column $j$ of $\mathbf{C}^{\sigma} \boxring \mathbf{J}$ is $\bigboxplus\limits_{l \in [r]} c_{i,l}^{\sigma} \boxdot J_{l,j}$. Since $J_{l,j}$ contains zero errors, the invariant equation on the product \ref{eq:invariant_product} yields that the error for each GSW ciphertext $c_{i,l}^{\sigma} \boxdot J_{l,j}$ is $(e_{i,l}^{\sigma})^T G^{-1}(J_{l,j}) \in \mathcal{E}$. The total error associated with $\bigboxplus\limits_{l \in [r]} c_{i,l}^{\sigma} \boxdot J_{l,j}$ is therefore $\sum\limits_{l=1}^r (e_{i,l}^{\sigma})^T G^{-1}(J_{l,j})$. By lemma \ref{lemma:Ver12}, $(e_{i,l}^{\sigma})^T G^{-1}(J_{l,j})$ is subgaussian with parameter $O(\|e_{i,l}^{\sigma}\|)$. Addition of subgaussian vectors from Lemma \ref{lemma:add-subgaussian} gives that the total error is subgaussian with parameter $O(\|e_i^{\sigma}\|)$ where $e_i^{\sigma}$ is the $i$:th row of $\mathbf{E}^{\sigma}$. The same analysis applies to every entry in the error associated with $\mathbf{C}^{\sigma} \boxring \mathbf{J}$ and thus the error is $\mathbf{E}^{\sigma} G^{-1}(\mathbf{J}) \in \mathcal{E}^{r \times r}$. Furthermore, row $i$ is a subgaussian vector over $\mathcal{E}^r$ with parameter $O(\|e^{\sigma}_i\|)$ since every entry is subgaussian with parameter $O(\|e^{\sigma}_i\|)$.
\end{proof}
\begin{theorem}\label{thm:HEPerm_product}
    Let $\mathbf{C}^{\pi} = (c^{\pi}_{i,j}), \mathbf{C}^{\sigma} = (c^{\sigma}_{i,j}) \in \mathcal{Y}^{r \times r}$ be two HEperm ciphertexts designed to encrypt the cyclic shifts $\pi, \sigma \in C_r$ with associated errors $\mathbf{E}^{\pi} = (e^{\pi}_{i,j}), \mathbf{E}^{\sigma} = (e^{\sigma}_{i,j}) \in \mathcal{E}^{r \times r}$ respectively. Then, $\mathbf{C}^{\pi} \boxring \mathbf{C}^{\sigma} \boxring \mathbf{J}$ is designed to encrypt $\pi \circ \sigma \in C_r$ and its associated error is
    \begin{equation}
        \mathbf{E}^{\pi} G^{-1}(\mathbf{C}^\sigma \boxring \mathbf{J}) + \mathbf{P}^{\pi} \mathbf{E}^{\sigma}G^{-1}(\mathbf{J}) \in \mathcal{E}^{r \times r} 
    \end{equation}
    where $\mathbf{P}^{\pi} = (p^{pi}_i,j) \in \{0,1\}^{r \times r}$ is the permutation matrix corresponding to $\pi$. Furthermore, row $i$ is subgaussian vector over $\mathcal{E}^r$ with parameter $O(\|e_i\|)$ where $e_i \in \mathcal{E}^{2r}$ is the $i$:th row of the concatenated matrix $[\mathbf{E}^{\pi} | \mathbf{E}^{\sigma}]$. 
\end{theorem}
\begin{proof}
    Remember that $\boxring$ is right associative. Therefore, $\mathbf{C}^\pi$ acts on the HEPerm ciphertext $\mathbf{C}^{right} \stackrel{\mathrm{def}}{=} \mathbf{C}^\sigma \boxring \mathbf{G} \in \mathcal{Y}^{r \times r}$ with error $\mathbf{E}^{right} \stackrel{\mathrm{def}}{=} \mathbf{E}^{\sigma} G^{-1}(\mathbf{J})$. For the HEPerm ciphertext , consider the GSW ciphertext element on row $i$ and column $j$. Unlike the above proof where $\mathbf{J}$ contained zero errors, here the right hand ciphertext $\mathbf{C}^{right}$ does contain errors. Therefore, the error associated with the GSW ciphertext on row $i$, column $j$ of $\mathbf{C}^{\pi} \boxring \mathbf{C}^{\sigma} \boxring \mathbf{J}$ is, by \ref{eq:invariant_sum} and \ref{eq:invariant_product} along row $i$ of $\mathbf{C}^{\pi}$ and column $j$ of $\mathbf{C}^{right}$, given by
    \begin{equation*}
        \sum\limits_{l=1}^r (e_{i,l}^{\pi})^T G^{-1}(c^{right}_{l,j}) + p^{\pi}_{i,l}e^{right}_{l,j}
    \end{equation*}
    where the bit $p^{\pi}_{i,l}$ is $1$ for exactly one $l$, namely $l = \pi^{-1}(i)$. In other words, the error for the entry on row $i$, column $j$ is $\sum\limits_{l=1}^r (e_{i,l}^{\pi})^T G^{-1}(c^{right}_{l,j}) + e^{right}_{\pi^{-1}(i),j}$ By the same argument as before, the first term (i.e., the sum over $l$) is subgaussian with parameter $O(\|e^{\pi}_i\|)$ where $e^{\pi}_i$ is the $i$:th row of $\mathbf{E}^{\pi}$. The second term is, by Lemma \ref{lemma:HEperm_error}, subgaussian with error $O(\|e^{\sigma}_{\pi^{-1}(i)}\|)$ where $e^{\sigma}_{\pi^{-1}(i)}$ is the $\pi^{-1}(i)$:th row of $\mathbf{E}^\sigma$. \mrnote{HOW DO I GET THIS TO BE THE i:th ROW?}. By the result on addition of subgaussian vectors, Lemma \ref{lemma:add-subgaussian}, the error associated with the GSW ciphertext on row $i$, column $j$ is therefore $O(\|e_i\|)$. The same analysis applies to every entry in the error associated with $\mathbf{C}^{\pi} \boxring \mathbf{C}^{\sigma} \boxring \mathbf{J}$ and thus the error is $\mathbf{E}^{\pi} G^{-1}(\mathbf{C}^\sigma \boxring \mathbf{J}) + \mathbf{P}^{\pi} \mathbf{E}^{\sigma}G^{-1}(\mathbf{J}) \in \mathcal{E}^{r \times r}$. Furthermore, row $i$ is a subgaussian vector over $\mathcal{E}^r$ with parameter $O(\|e_i\|)$ since every entry in that row is subgaussian with parameter $O(\|e_i\|)$. 
\end{proof}
\begin{corollary}\label{cor:HEPerm_product}
    Let $\mathbf{C}_1, \dots, \mathbf{C}_k$ be HEperm ciphertext designed to encrypt cyclic shifts $\pi_1, \dots, \pi_k$ with associated errors $\mathbf{E}_1, \dots, \mathbf{E}_k \in \mathcal{E}^{r \times r}$, respectively. Then,
    \begin{equation}
        \mathbf{C}_1 \boxring \dots \boxring \mathbf{C}_k \boxring \mathbf{J}
    \end{equation}
    is designed to encrypt $\pi_1 \circ \dots \circ \pi_k$. Furthermore, the $i$:th row of its associated error is subgaussian with parameter $O(\|e_i\|)$ where $e_i \in \mathcal{E}^{kr}$ is the $i$:th row of the concatenated matrix $[\mathbf{E}_1 | \dots | \mathbf{E}_k]$.
    % Maybe show what the error actually is too.
\end{corollary}

\section{Bootstrapping}
In this section we show how to use the HEPerm scheme to bootstrap the GSW scheme, using the HEPerm composition operation and the Equality test operation. Remember that bootstrapping algorithm takes as input a noisy ciphertext with an encryption of a secret key and outputs a new ciphertext with smaller noise, by decrypting the ciphertext homomorphically (meaning using the encrypted the secret key instead of the real secret key). Technically, the bootstrapping procedure consists of two algorithms, BootGen() which is run by the client to generate an encryption of the secret key and Bootstrap() which is run by the server for homomorphic decryption, using the encrypted secret key. BootGen() returns a so called bootstrap key, $bk$, that is a matrix of HEPerm ciphertexts. Element $i$ of the secret key is encrypted and represented by column $i$ of $bk$. The server computes the inner product and the rounding function homomorphically. The inner product is implemented by using the HEPerm composition operation and the rounding function is implemented by using the equality test operation.

Before presenting the algorithms, let us first consider the decryption process. Decryption starts with calculating the inner product of the secret key, $s \in \mathbb{Z}_q$ with the penultimate column of the ciphertext $c_{pen} \in \mathbb{Z}_q$. Remark that if $c_{pen}$ is defined over $\{0,1\}$, then this inner product becomes a subset sum over $(s_1, \dots, s_n)$. As we will see later, this would allow us to calculate the inner product homomorphically using the HEPerm scheme. The idea is therefore to convert $c_{pen}$ to binary using the ordinary bit decomposition of $c_{pen}$, denoted $c_{pen}' \in \{0,1\}^{nl}$. Remark that $c_{pen}'$ satisfies $\mathbf{G}c_{pen}' = c_{pen}$. To make the dimensions match, we consider the vector $s' \stackrel{\mathrm{def}}{=} G^T s \in \mathbb{Z}_q^{nl}$. Then, we have that $\left \langle s', c_{pen}' \right \rangle = s'^T c_{pen}' = (\mathbf{G}^T s)^T c_{pen}' = s^T \mathbf{G} c_{pen}' = s^T c_{pen} = \left \langle s,c_{pen} \right \rangle$. Therefore, we can calculate the inner product homomorphically by calculating $\left \langle s', c_{pen}' \right \rangle$ homomorphically. Instead of using the encryption of the normal secret key $s$, the bootstrapping algorithm uses the encryption of $s'$ using the HEPerm scheme. In other words, the client runs the BootGen() algorithm using the modified secret key $s' \in \mathbb{Z}_q^{nl}$ whereas the server runs Bootstrap() using the modified ciphertext $c_{pen}' \in \{0,1\}^{nl}$.

This section is heavily based on the theory presented in Section \ref{sec:embedding}. In particular, remember that we can choose modulus $q = \prod\limits_{i \in [t]}r_i$ such that every integer mod $q$ can be represented by $t = O(\frac{\log q}{\log \log q})$ cyclic shifts, where each $r_i = O(\log q)$ is a prime power. Also remember that for an integer $s_j \in \mathbb{Z}_q$, $\phi_i(s_j)$ is the cyclic shift representing the integer $s_j \pmod {r_i}$. As a last note, the bootstrapping algorithm presented in \cite{A-S-P-boot} applies to all LWE based schemes whereas in this thesis, we will look specifically at the GSW scheme and therefore simplify the notation.

\begin{definition}(BootGen)
    Define the BootGen algorithm taking the secret key $s' = (s_1', \dots, s_{nl}') \in \mathbb{Z}_q^{nl}$ and the public key $\mathbf{A}'$ of the GSW scheme as the following $t \times nl$ sized matrix of HEPerm ciphertexts
    \begin{equation}\label{bk}
        bk =
        \left[
        \begin{array}{ccc}
            \mathbf{C}_{1,1} & \cdots & \mathbf{C}_{1,nl} \\
            \vdots & \ddots  & \vdots\\
            \mathbf{C}_{t,1}  & \cdots & \mathbf{C}_{t,nl} 
        \end{array}
        \right]
    \end{equation}
    where $\mathbf{C}_{i,j} \leftarrow \text{HEPerm.Enc}(\mathbf{A}', \phi_i(s_j'))$ for $i \in [t]$ and $j \in [nl]$.
\end{definition}
Notice that $\mathbf{C}_{i,j}$ is an HEPerm encryption of $s_j' \pmod {r_i}$ and that row $i$ therefore contains $s_j' \pmod {r_i}$ for every $s_j'$ in the modified secret key. Furthermore, column $j$ is an encryption of the canonical embedding of $s_j'$. Since every HEPerm ciphertext is a square matrix of GSW ciphertexts, every column of HEPerm ciphertexts contains $\sum\limits_{i \in t} r_i^2$ GSW ciphertexts for a total of $nl \sum\limits_{i \in t} r_i^2$ GSW ciphertexts in $bk$. Remark that in practice, this would be reduced to $nl \sum\limits_{i \in t} r_i$ GSW ciphertext by instead letting the every HEPerm ciphertext consist of a column of $r_i$ ciphertexts. However, when computing the inner product homomorphically, $\boxring$ requires the square representation with $r_i^2$ GSW ciphertexts. The server can expand the column by letting each new column be a cyclically rotated version of the first column. 
\subsection*{Inner product}
We start by discussing how to calculate the inner product normally (meaning when the secret key is not encrypted) using cyclic shifts. Note that inner product is equivalent to calculating a subset sum of $s'$  since $\left \langle s, c_{pen} \right \rangle = \left \langle s', c_{pen}' \right \rangle = \sum\limits_{\{j \in [nl]: c_{pen,j}' = 1\}} s_j'$. By using Equation \ref{cyclic-sum}, we can calculate this sum with the canonical homomorphism by considering compositions of cyclic shifts. More specifically, we can consider each moduli $r_i$ separately and calculate the integer $\sum\limits_{\{j \in [nl]: c_{pen,j}' = 1\}} s_j' \pmod {r_i}$ as the the corresponding cyclic shift $\mathop{\bigcirc}\limits_{\{j \in [nl]: c_{pen,j}' = 1\}} \phi_i(s_j') \in S_{r_i}$. Repeating for every $i$ yields a tuple of $t$ cyclic shifts that together uniquely represents the subset sum (and thus also the inner product). Now, we want to do the same operation homomorphically using the bootstrap key $bk$. Note that row $i$ in $bk$ represents HEPerm ciphertexts of $s_j' \pmod {r_i}$ for every $j \in [nl]$. Therefore, to calculate the inner product homomorphically, the idea is to pick out the columns $j$ such that $c_{pen,j}' = 1$ and calculate the HEPerm composition of ciphertext. Since HEPerm preserves design, the resulting HEPerm ciphertext is designed to encrypt $\sum\limits_{\{j \in [nl]: c_{pen,j}' = 1\}} s_j' \pmod {r_i}$. More formally, the inner product is a column vector with $t$ HEPerm ciphertexts where entry $\mathbf{C}_i$ is defined as the following HEPerm composition
\begin{equation}\label{eq:inner_product}
    \mathbf{C}_{i} = \bigboxring\limits_{\{j \in [nl]: c_{pen,j}' = 1\}} \mathbf{C}_{i,j} \boxring \mathbf{J} \in \mathcal{Y}^{r_i}
\end{equation}
where $\mathbf{C}_{i,j}$ is the HEPerm ciphertext on row $i$, column $j$ of $bk$ which is designed to encrypt cyclic shift $\phi_i(s_j)$, meaning integer $s_j \pmod {r_i}$. We include the zero error HEPerm ciphertext $\mathbf{J}$ to allow for Corollary \ref{cor:HEPerm_product} in the error analysis later. 

Consider the quick example where $c_{pen}' = (1, 0, 0, \dots, 0, 0, 1) \in \{0,1\}^{nl}$. Then, then the encrypted inner product is $(\mathbf{C}_{1,1} \boxring \mathbf{C}_{1,nl} \boxring \mathbf{J}, \mathbf{C}_{2,1} \boxring \mathbf{C}_{2,nl} \boxring  \mathbf{J}, \dots, \mathbf{C}_{t,1} \boxring \mathbf{C}_{t,nl} \boxring \mathbf{J})^T$ where $\mathbf{C}_{i,1} \boxring \mathbf{C}_{i,nl} \boxring \mathbf{J}$ is the HEPerm ciphertext designed to encrypt $\left \langle s, c \right \rangle \pmod {r_i}$

\subsection*{Rounding function}
Denote the encrypted inner product calculated using Equation \ref{eq:inner_product} by $\alpha$. Since $\alpha$ is designed to encrypt $\left \langle s, c_{pen} \right \rangle$, to compute the decryption function homomorphically, we need to compute the rounding function on $\alpha$. The Equality test function takes the encrypted inner product $\alpha$ and a cyclic shift representation of an integer $x \in \mathbb{Z}_q$ such that $[x]_2 = 1$. The idea is to pick out the $t$ GSW ciphertexts in the $t$ HEperm ciphertexts in $\alpha$ that corresponds to the integer $x$ and then use $\boxdot$ operation to multiply the $t$ GSW ciphertexts together. This results in a GSW ciphertext product designed to encrypt $1$ if and only if every chosen GSW ciphertext is designed to encrypt one, which is the case if and only if $\alpha$ is designed to encrypt $x$. If any of the $t$ GSW ciphertexts is not designed to encrypt the corresponding cyclic shift in $\phi(x)$, then the product ciphertext is designed to encrypt 0, meaning $\alpha$ is not designed to encrypt $x$. Note however that $\alpha$ can be designed to encrypt some other integer rounded to $1$. Therefore, it is necessary to run the equality test function on every "good" integer $x$, where "good" means it is rounded to 1, and take the sum of all the resulting GSW ciphertexts. The sum is then designed to encrypt $1$ if and only if $\alpha$ is designed to encrypt any one of the good integers and designed to encrypt $0$ otherwise. More formally, the rounding function can be implemented homomorphically as follows:
\begin{equation}\label{eq:rounding_function}
    [\alpha]_2 = \bigboxplus\limits_{\{x \in \mathbb{Z}_q: [x]_2 = 1\}} \Bigl( \text{Eq?}(\mathbf{C}_1, \phi_1(x)) \boxdot \dots \boxdot \text{Eq?}(\mathbf{C}_t, \phi_t(x)) \boxdot \mathbf{G} \Bigr) \in \mathcal{Y}
\end{equation}
We include the zero error GSW ciphertext $\mathbf{G}$ to allow for Corollary \ref{cor:hom_product} in the error analysis later. $[\alpha]_2$ is the refreshed GSW ciphertext of the original GSW ciphertext and is the output value of the bootstrap algorithm. In other words, $[\alpha]_2 \leftarrow \text{Bootstrap}(bk,c_{pen}')$ where generating $bk$ is preprocessing made by the client and calculating $c_{pen}'$ from the original ciphertext is a preprocessing step made by the server. It is clear by the arguments above that $[\alpha]_2$ indeed is designed to encrypt the same bit that the original ciphertext encrypts.

So far, we have only talked about how computing the inner product and the rounding function homomorphically preserves the design of the original ciphertext. In other words, $[\alpha]_2$ decrypts to the same bit as the original ciphertext assuming error are small enough. However, in reality the the bootstrapping returns another noisy ciphertext as a result of the computations on the encrypted secret key. More specifically, when calculating the inner product homomorphically, the HEPerm ciphertexts in each row of the bootstrap key is composed using $\boxring$ for a maximum of $nl$ times. Furthermore, when calculating the rounding function, there are $O(q)$ sums of GSW ciphertext where each is a product of $t$ GSW ciphertexts. Below, we analyze the error growth in the bootstrapping algorithm and later show how to choose parameters such that the error associated to the refreshed ciphertext is small enough to result in correct decryption.

\section{Errors in bootstrapped ciphertext}
In the following section, we denote parameter in the subgaussian, discrete error distribution $\chi$ as $s$. Furthermore, we let $r$ denote the sum $\sum\limits_{i \in t} r_i$.

\begin{lemma}[Error of homomorphic innerproduct]\label{lemma:inner_product_error}
    Let $\mathbf{C}_i$ denote the HEPerm ciphertext designed to encrypt $\left \langle s, c_{pen} \right \rangle \pmod {r_i}$ for $i \in [t]$, as defined by Equation \ref{eq:inner_product}. Then, every row in the error $\mathbf{E}_i \in \mathcal{E}^{r_i}$ associated with $\mathbf{C}_i$ is subgaussian with parameter $O(snl\sqrt{r_i})$. Furthermore, every row has length bounded by $O(s(nl)^\frac{3}{2}\sqrt{r_i})$ except for probability $2^{-\Omega(nl)}$.
\end{lemma}
\begin{proof}
    Remember that $\mathbf{C}_{i,j}$ contains $r_i$ GSW ciphertext with $r_i$ associated errors in $\mathcal{E} = \mathbb{Z}^{nl}$. Since each GSW ciphertext in $\mathbf{C}_{i,j}$ is a fresh GSW encryption, each associated error contains subgaussian random variables over $\mathbb{Z}$ with parameter $O(s)$. To bound the error growth, assume that $c_{pen}' \in \{0,1\}^{nl}$ is the vector with all $1$, meaning that the homomorphic inner product consists of exactly $nl$ $\boxring$ operations in Equation \ref{eq:inner_product}. Concatenating all $nl$ rotation expanded error matrices yields a matrix in $\mathcal{E}^{r_i \times r_i n l} = \mathbb{Z}^{r_i \times r_i n^2l^2}$. Take any row $x$ in this concatenated error vector. Then $x \in \mathbb{Z}^{r_in^2l^2}$ and by Theorem \ref{thm:length-subgaussian}, $\|x\|$ is $O(s n l \sqrt{r_i})$ except for probability $2^{-\Omega(nl\sqrt{r_i})}$. Therefore, by Corollary \ref{cor:HEPerm_product}, every row of the error associated with $\mathbf{C}_i$ is subgaussian with parameter $O(\|x\|) = O(snl\sqrt{r_i})$. Futhermore, since any row of $\mathbf{E}_i \in \mathcal{E}^{r_i}$ is defined over $\mathbb{Z}^{n l}$, invoking Theorem \ref{thm:length-subgaussian} again yields that the length over the integers of any row vector in the error matrix is $O(s(nl)^\frac{3}{2}\sqrt{r_i})$ except for probability $2^{-\Omega(nl)}$. Since $2^{-\Omega(nl)}$ dominates $2^{-\Omega(nl\sqrt{r_i})}$, the proof is complete.
\end{proof}
\begin{theorem}[Error of bootstrapped ciphertext]
    The error associated with the GSW ciphertext $[\alpha]_2$ in Equation \ref{eq:rounding_function} is subgaussian with parameter $O(s(nl)^\frac{3}{2}\sqrt{rq})$ except for probability $2^{-\Omega(nl)}$. 
\end{theorem}
\begin{proof}
    By the previous Lemma, the error associated with each $\mathbf{C}_i$ has subgaussian row vectors with length over the integers bounded by $O(s(nl)^\frac{3}{2}\sqrt{r_i})$. Consider the concatenated vector $(e_1, \dots, e_{t}) \in \mathbb{Z}^{tnl}$ where $e_i \in \mathbb{Z}^{nl}$ is any row in error matrix $\mathbf{E}_i$. Then, this concatenated vector has length $\sqrt{\|e_1\|^2 + \dots + \|e_t\|^2}$. By Corollary \ref{cor:hom_product}, the error associated with the GSW ciphertext product $\text{Eq?}(\mathbf{C}_1, \phi_1(x)) \boxdot \dots \boxdot \text{Eq?}(\mathbf{C}_t, \phi_t(x)) \boxdot \mathbf{G}$ is subgaussian with parameter $O(\sqrt{\|e_1\|^2 + \dots + \|e_t\|^2}) = O(\sqrt{(s(nl)^\frac{3}{2}\sqrt{r_1})^2 + \dots + (s(nl)^\frac{3}{2}\sqrt{r_1})^2}) = O(s(nl)^\frac{3}{2}\sqrt{r})$. Since the rounding function computes the sum of $q$ GSW ciphertexts in Equation \ref{eq:rounding_function}, additivity of subgaussian vectors from Lemma \ref{lemma:add-subgaussian} implies that the error associated with the final bootstrapped GSW ciphertext is subgaussian with parameter $O\Bigl(\sqrt{\sum\limits_{i = 1}^{q}(s(nl)^\frac{3}{2}\sqrt{r})^2}\Bigr) = O(s(nl)^\frac{3}{2}\sqrt{rq})$
\end{proof}


\section{Parameters}

% The encrypted bit satisfies the invariant equation since $s^T\mathbf{C} = bs^T\mathbf{G} + s^T\mathbf{A}' \times \mathbf{R}= bs^T\mathbf{G} + e^T \mathbf{R}$ where the ciphertext error $e^T \mathbf{R}$ is subgaussian with parameter $O(\|e\|)$ bounded by $m \|e^T\| \leq m \times n$ from KeyGen process. Furthermore, the evaluated ciphertext also satisfies the invariant equation and the noise grows by at most by a factor $nl + 1$ per layer. Therefore, for any circuit $C$, the error at depth $d$ is bounded by $nm(nl+1)^d$.

% To argue correctness, we need to show that decryption works for all layers less than or equal to the permissible depth, $L$. Assume decryption at depth $d \leq L$, meaning $\|e^T\| \leq nm(nl+1)^d$. Then $s^T \times \mathbf{C} \times G^{-1}(w) =  (bs^T\mathbf{G} + e^T)G^{-1}(w) = bs^T\mathbf{G}G^{-1}(w) + e^TG^{-1}(w) = b\langle s^T, w\rangle + \langle e^T, G^{-1}(w)\rangle = b\frac{q}{2} + \langle e^T, G^{-1}(w)\rangle$ where $|\langle e^T, G^{-1}(w)\rangle | \leq \|e^T\| \leq nm(nl+1)^d$. To ensure the scheme can handle circuits of depth $L$, the parameters must satisfy $nm(nl+1)^L < \frac{q}{4}$. In other words, the global modulus $q$ must be larger for greater depth parameter $L$. For explicit parameters $n, q, \chi, m$ that satisfies the above condition while maintaining LWE hardness assumption, see \cite{Hal18}. 

% The security of the scheme follows from the LWE hardness assumption; since $\mathbf{A}'$ is pseudorandom and $\mathbf{R}$ is a uniformly random matrix over $\{0,1\}$, the $n \times nl$ matrix $\mathbf{A}'\mathbf{R}$ simply contains $nl$ LWE samples. Therefore, adding $b\mathbf{G}$ is computationally indistinguishable, meaning the ciphertext $C$ is pseudorandom.

% Notice that since $q$ is dependent on maximum depth $L$, the GSW scheme is leveled and not pure FHE as it currently stands. However, the bootstrapping theorem together with circular security assumption can be used to turn the leveled GSW scheme into a pure FHE scheme. To decrypt a ciphertext homomorphically, we first calculate $v \stackrel{\mathrm{def}}{=} \mathbf{C} \times G^{-1}(w)$ using only public information as a pre-processing step. Then, the actual decryption is done by computing $[\langle s^T, v \rangle]_q$. It turns out that modular inner products can be calculated by circuits with depth logarithmic in the size of the inputs, meaning depth $O(\log(s + v)) = O(\log(n \log q))= O(\log n + \log\log(q))$.\footnote{To see how to construct such a circuit, see \cite{Hal18}.}
% \begin{theorem}
%     The GSW scheme is bootstrappable.
% \end{theorem}
% \begin{proof}
% We want to show that the augmented decryption function can be evaluated homomorphically for some set of parameters. Assume augmented decryption function has depth $d = O(\log(n) + \log\log(q))$ for some real number. Then, the parameters must satisfy $4nm(nl+1)^d < q$. Since $m,n = \operatorname{poly}(\lambda)$, there exists some integer $\gamma$ such that $4nm(nl+1)^{d} \leq (nl)^{\gamma + d} = (n\lceil\log q \rceil)^{\gamma + d} = (n \lceil\log q \rceil ) ^{O(\log(n) + \log\log(q))}$. Therefore, it is sufficient to show that there exists parameters such that $(n \lceil\log q \rceil ) ^{\delta (\log(n) + \log\log(q))} \leq q$ for some real value $\delta$ and sufficiently large $\lambda$. Let $q = 2^{3\delta\log^2(n)}$.
% \begin{equation*}
%     \begin{aligned}
%         (n \lceil \log q \rceil )^{\delta (\log n + \log \log q)} &= (n \lceil 3\delta \log^2(n) \rceil)^{\delta (\log n + \log^2 q)}\\
%         & \leq (2^{\log(n)})^{\delta (\log n + \log^2 q)}\\
%         & = (2^{\log(n)})^{\delta (\log n + \log (3\delta \log^2n))} \\
%         & \leq (2^{\log(n)})^{\delta (\log n + \log (3\delta) + \log^3n)} \\
%         & \leq (2^{\log(n)})^{\delta (3\log n)} \\
%         & = (2^{3\delta\log^2(n)})\\
%         & = q
%     \end{aligned} 
% \end{equation*}
% Since GSW is bootstrappable, it is pure FHE (under circular security) as per the bootstrapping theorem (see theorem \ref{thm:bootstrapping}).
% \end{proof}

\section{Efficiency improvements}